/**
* QEDIT - Asset Transfers
* This SDK provides a programmatic way for interacting with QEDIT's _Asset Transfer_ API. The specification definition file is publicly available [in this repository](https://github.com/QED-it/asset_transfers_dev_guide/). 
*
* OpenAPI spec version: 1.8.0
* Contact: dev@qed-it.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.client.apis

import org.openapitools.client.models.AsyncTaskCreatedResponse
import org.openapitools.client.models.DeleteWalletRequest
import org.openapitools.client.models.ErrorResponse
import org.openapitools.client.models.ExportAuditorAccessWalletRequest
import org.openapitools.client.models.ExportAuditorAccessWalletResponse
import org.openapitools.client.models.ExportWalletRequest
import org.openapitools.client.models.ExportWalletResponse
import org.openapitools.client.models.GenerateWalletRequest
import org.openapitools.client.models.GetAllWalletsResponse
import org.openapitools.client.models.GetNotificationsRequest
import org.openapitools.client.models.GetNotificationsResponse
import org.openapitools.client.models.GetRulesResponse
import org.openapitools.client.models.GetTaskStatusRequest
import org.openapitools.client.models.GetTaskStatusResponse
import org.openapitools.client.models.GetTasksRequest
import org.openapitools.client.models.GetTasksResponse
import org.openapitools.client.models.ImportAuditorAccessWalletRequest
import org.openapitools.client.models.ImportWalletRequest
import org.openapitools.client.models.TaskActionRequest

import org.openapitools.client.infrastructure.*

class NodeApi(basePath: kotlin.String = "https://localhost") : ApiClient(basePath) {

    /**
    * Approve task with pending incoming transaction [async call]
    * Confirmation request tasks are confirmed using this point. After the user confirms the incoming transaction, it is asynchronously sent to the blockchain and its status can be queried like any other async task.
    * @param taskActionRequest  
    * @return void
    */
    fun nodeApproveTaskPost(taskActionRequest: TaskActionRequest) : Unit {
        val localVariableBody: kotlin.Any? = taskActionRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/approve_task",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Cancel task with pending incoming transaction both incoming and outgoing [async call]
    * A user may select to decline an incoming transaction. The related task will change its result to failure both on senders and the receivers side. This endpoint can also be used to cancel an outgoing pending transaction that is awaiting user interaction from the receiver
    * @param taskActionRequest  
    * @return AsyncTaskCreatedResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeCancelTaskPost(taskActionRequest: TaskActionRequest) : AsyncTaskCreatedResponse {
        val localVariableBody: kotlin.Any? = taskActionRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/cancel_task",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AsyncTaskCreatedResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AsyncTaskCreatedResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Delete a Wallet [async call]
    * Deletes a Wallet from the Node; All private information about the Wallet will be deleted including transactional history, balances, and keys; If the secret key of the Wallet are not stored elsewhere then all Assets held in the Wallet will be forever lost! If the secret key of the Wallet is stored elsewhere, then all held Assets and the entire transactional history of the Wallet can be restored from the Blockchain at any time by importing the Wallet into a Node.
    * @param deleteWalletRequest  
    * @return AsyncTaskCreatedResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeDeleteWalletPost(deleteWalletRequest: DeleteWalletRequest) : AsyncTaskCreatedResponse {
        val localVariableBody: kotlin.Any? = deleteWalletRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/delete_wallet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AsyncTaskCreatedResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AsyncTaskCreatedResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Export viewing credentials for a Wallet
    * Export a viewing key that allows viewing all transactions to and from a wallet, including past transactions. The viewing key is encrypted for a specific Address, and can only be recovered by someone in possession of either a secret key or a viewing key for the Wallet that Address belongs to. The viewing key does enable making any transactions (including rule changes, issuance, and transfers) on behalf of the exported Wallet.
    * @param exportAuditorAccessWalletRequest  
    * @return ExportAuditorAccessWalletResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeExportAuditorAccessWalletPost(exportAuditorAccessWalletRequest: ExportAuditorAccessWalletRequest) : ExportAuditorAccessWalletResponse {
        val localVariableBody: kotlin.Any? = exportAuditorAccessWalletRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/export_auditor_access_wallet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ExportAuditorAccessWalletResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExportAuditorAccessWalletResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Export wallet secret key
    * Export an encrypted form of the Wallet&#39;s secret key; The authorization password under which the secret key is encrypted is the same one under which it was originally created or imported; Knowledge of the secret key and the authorization password is required to import the Wallet into a Node in the future.
    * @param exportWalletRequest  
    * @return ExportWalletResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeExportWalletPost(exportWalletRequest: ExportWalletRequest) : ExportWalletResponse {
        val localVariableBody: kotlin.Any? = exportWalletRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/export_wallet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ExportWalletResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExportWalletResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Generate a new Wallet
    * Randomly generate a new Wallet under a specified ID; This only affects the Node and in particular nothing about this action is broadcast to the Blockchain; The Wallet ID is required to be unique within the Node, but can otherwise be user-defined.
    * @param generateWalletRequest  
    * @return void
    */
    fun nodeGenerateWalletPost(generateWalletRequest: GenerateWalletRequest) : Unit {
        val localVariableBody: kotlin.Any? = generateWalletRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/generate_wallet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get all wallet IDs
    * Returns a list of the IDs of all Wallets currently stored on the Node. Both full-access and view-only Wallets are listed.
    * @return GetAllWalletsResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeGetAllWalletsPost() : GetAllWalletsResponse {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/get_all_wallets",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<GetAllWalletsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetAllWalletsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get notifications
    * Notifications are the Node&#39;s way to report about recent activity and status changes. This endpoint allows polling for these changes and fetching the updates. The notifications can be filtered in multiple ways.
    * @param getNotificationsRequest  
    * @return GetNotificationsResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeGetNotificationsPost(getNotificationsRequest: GetNotificationsRequest) : GetNotificationsResponse {
        val localVariableBody: kotlin.Any? = getNotificationsRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/get_notifications",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<GetNotificationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetNotificationsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get network governance Rules
    * Returns a full list of all the Rules that govern admin and issuance rights within the network.
    * @return GetRulesResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeGetRulesPost() : GetRulesResponse {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/get_rules",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<GetRulesResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetRulesResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a specific task (by ID)
    * Returns the meta-data of a given Task and its current status. The particular, private details of the Task such as an Asset ID or amount in a Transfer are not returned.
    * @param getTaskStatusRequest  
    * @return GetTaskStatusResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeGetTaskStatusPost(getTaskStatusRequest: GetTaskStatusRequest) : GetTaskStatusResponse {
        val localVariableBody: kotlin.Any? = getTaskStatusRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/get_task_status",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<GetTaskStatusResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetTaskStatusResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a (potentially) filtered list of all Tasks
    * Returns a list of all Tasks along with their meta-data and statuses. The particular, private details of the Task such as an Asset ID or amount in a Transfer are not returned. Tasks can be filtered using various parameters as specified in the request body.
    * @param getTasksRequest  
    * @return GetTasksResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeGetTasksPost(getTasksRequest: GetTasksRequest) : GetTasksResponse {
        val localVariableBody: kotlin.Any? = getTasksRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/get_tasks",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<GetTasksResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetTasksResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Import viewing credentials for a Wallet [async call]
    * Import a viewing key generated by the export_auditor_access_wallet endpoint. This will create a read-only wallet which can be queried with endpoints such as get_activity and get_balances, but cannot be used to perform transactions. The Wallet whose Address was used as the recipient for the exported viewing key must already be imported within the Node in order for this process to succeed.
    * @param importAuditorAccessWalletRequest  
    * @return AsyncTaskCreatedResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeImportAuditorAccessWalletPost(importAuditorAccessWalletRequest: ImportAuditorAccessWalletRequest) : AsyncTaskCreatedResponse {
        val localVariableBody: kotlin.Any? = importAuditorAccessWalletRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/import_auditor_access_wallet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AsyncTaskCreatedResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AsyncTaskCreatedResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Import Wallet from a known secret key and authorization [async call]
    * Import a Wallet into the Node under a specified ID; All the transactional history and outstanding balanced of the Wallet will be extracted from the Blockchain; The Wallet ID is required to be unique within the Node, but can otherwise be user-defined.
    * @param importWalletRequest  
    * @return AsyncTaskCreatedResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun nodeImportWalletPost(importWalletRequest: ImportWalletRequest) : AsyncTaskCreatedResponse {
        val localVariableBody: kotlin.Any? = importWalletRequest
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/node/import_wallet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AsyncTaskCreatedResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AsyncTaskCreatedResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
